<<<<<<< HEAD
﻿Ragnarok 0.9.0 BETA
=======
Ragnarok 0.1 BETA C# Rebuild
>>>>>>> 36e55ad4186ca872cebfd010e989701560be0c12
===========

加密聊天器

服务端 
------
<<<<<<< HEAD
=======
Ragnarok_server\server.py 

python3.6.4

### 说明

考虑到很多宽带都是NAT的内网，所以通过公网小鸡桥接。

服务端只做用户合法性验证和双向搭桥，可以放在国内小鸡上。
>>>>>>> 36e55ad4186ca872cebfd010e989701560be0c12

Ragnarok_server\server.py

python3.6.4

<<<<<<< HEAD
### 说明
=======
### 设置
在config里改小鸡的公网IP和端口，对linux了解不太多，所以怎么在服务器上运行还请dalao写个shell加进来（写了个实验版后台shell）
>>>>>>> 36e55ad4186ca872cebfd010e989701560be0c12

考虑到很多宽带都是 NAT 的内网，所以通过公网小鸡桥接。

<<<<<<< HEAD
服务端只做用户合法性验证和双向搭桥，可以放在国内小鸡上。

有一根长长的网线，一直伸到你家里，你说什么做什么他们都知道的一清二楚。
=======
聊天模块
------
Ragnarok_C#

### 使用环境
请使用正版 win10 64bit 1709 (16299.248)

.NET Framework 4.7.1 

VS2017
>>>>>>> 36e55ad4186ca872cebfd010e989701560be0c12

于是我决定写这玩意，名字随便起的。再也不用担心被视奸了。

### 设置
<<<<<<< HEAD

在config里改端口，$ python3 server.py运行，对linux了解不太多，怎么在服务器上比较舒服的运行还请dalao写个shell加进来（写了个实验版后台shell）

### 碧油鸡

目前在破坏性测试中发现了两个奇怪的碧油鸡，一个是一方断开以后另一方发送消息会收到无限重复的空字节，至今没找到原因，只能重置服务端。另一个是服务端会在复杂线程的环境下，遇到了致命错误崩溃会导致客户端一起跟着崩溃。

聊天模块
------
Ragnarok C#

### 使用环境

请使用正版 win10 64bit 1709 (16299.248)

.NET Framework 4.7.1

###开发环境 

Visual Studio 2017

.NET Framework 4.7.1 Developer Pack


### 设置

UserID：你自己的代号，比如9527

TargetID：你想和谁说悄悄话

Target_IP：其实这个应该是serverIP，小鸡的地址
=======
UserID：你自己的代号,仅限大小写字母和数字

TargetID：你想和谁说悄悄话

Local_IP：本机的网口IP4，内网一般是192.168.xxx.xxx（不是网页查出来的公网IP）

Local_Port：0-65535

Target_IP：小鸡的公网IP

Target_Port：服务器监听端口

### 使用

先设置参数，再保存，再连接服务器，两个客户端都连上服务器以后，就可以开始网上冲浪了。

### 加密特性
C#重构的客户端，加密逻辑完全重写

大概阐述一下逻辑：

客户端A先行连接服务器，获得主动权。
>>>>>>> 36e55ad4186ca872cebfd010e989701560be0c12

|客户端A|    ---连接--→  |服务端|  ←--断开---     |客户端B|

<<<<<<< HEAD
### 标准操作程序 SOP
这客户端一复杂吧，碧油鸡就到处飞，按照SOP用，保证没问题。

1.小明和小红打开软件后设置成互为 TargetID ，并且使用相同的服务器地址和端口。

2.对服务器的握手连接完成后，点下“开始网上冲浪”，对方也点击后牵手成功。

3.进入聊天窗口进行秘钥交换和聊天隧道握手，发送按钮亮起后，即可开始尬聊。

4.传输文件点击“发福利”，等另一方接受后，发起方选择文件然后加密发送，发送方只要保持窗口打开就可以自动接收解码文件，接收到的文件在程序的根目录下。

5.当一个文件传输完成后，如果想继续传输文件，两边先确保关闭文件传输窗口，然后再由一方发起文件传输请求。

6.关闭客户端用正常方法关闭（用任务管理器乱搞的，电脑坏了不管）。

ps.由于python服务端的一些迷之算法和线程干扰，建议进行完一次加密通讯就重启一次服务端免得引起一些我自己都不知道怎么发生的故障。

### 加密特性

RSA(1024) + AES_CFB 

我就不吹有多保密了，除非你电脑上全是木马病毒大数字猥士和企鹅监控管家之类的玩意。等什么时候仔细做一个图解，感觉光打字说不清楚还绕的晕。趁着代码量还在记忆力能拯救我的范围之内，先这么凑合用着吧。
=======
|客户端A|    ---等待----   |服务端|     ←--断开---     |客户端B|

|客户端A|    ---等待----   |服务端|     ←--连接---     |客户端B|

|客户端A|    ←--桥接---   |服务端|     ---桥接--→     |客户端B|

|客户端A|    ---A公钥--→   |服务端|     ←--B公钥---     |客户端B|

|客户端A|    ←--B公钥---   |服务端|     ---A公钥--→     |客户端B|

|客户端A|     -AESkey→   |服务端|      -AESkey→     |客户端B|

|客户端A|     ---密文--→   |服务端|     ---密文--→     |客户端B|

客户端A用B公钥加密AESkey，返回客户端B，客户端B私钥解密得到AESkey

通信双方用客户端A产生的AESkey进行通信。

我就不吹有多保密了（量子计算机出来之前，谁都看不到你们说了什么悄悄话）但是有一些人为因素问题后面说。

>>>>>>> 36e55ad4186ca872cebfd010e989701560be0c12


人为因素
------
中间人攻击是个目前没有什么解决办法的事情，所以才有了CA去保证RSA公钥的可靠。一个程序中，最薄弱的环节是人。如果用最迫不得已的办法，显示接收到的秘钥以便在旁路（线下py交易，企鹅vx）上进行公钥可靠性的确认。不过不干坏事也不会招致高科技的中间人攻击……技术无罪。

另外考虑到社工的问题，ID最好不要起自己喜欢的一些字段。因为和服务器交换ID的时候是明文，可能是个隐患。


一些随笔
-----
2018年2月21日

历时一个月从什么都不懂，开始盲人摸蛇，到撸出来这个程序，今天算是瞎猫撞上死耗子撸出来了，差点弃坑。有的时候比较喜欢大开脑洞，比如2100年的一个晚上，K摘下了手表眼睛手机，带着一张写满英文数字的纸条出门了。在一个小巷和一个老哥擦肩而过的时候，仿佛手里的纸条有一点点的不一样。回到家，拿出爷爷的信仰阿苏斯笔记本，打开了Ragnarok，进入了这个cyberpunk时代最后的世外桃源。

<<<<<<< HEAD
2018年3月4日
没有大佬愿意用C#重做客户端，I can I up 了，狂啃一周MSDN和Stack Overflow，东拼西凑把这个C#客户端组装到一起，我狗命快不保了。

我宣布放弃python客户端的开发，毕竟命令行的IO操作太日狗，运行环境也需要额外搭建，对文件流加密的效率也低的可怕，线程一多起来就开始线程混乱，毕竟GIL的硬伤，py的gui唉不提了。客户端在C#上重构的开发速度非常快，测试起来非常方便，而且原生支持多线程和Gui操作，在给文件流加密的时候可以直接调用CPU指令集，于是变成我的nvme SSD的速度在限制着加密速度。xswl
=======
没有C#大佬，我就自己动手丰衣足食吧。安装和使用都会更方便。不过命令行更有黑客的感觉，做人不装逼，和咸鱼有什么区别。
>>>>>>> 36e55ad4186ca872cebfd010e989701560be0c12

做了个文件传输以后，我实在是想不出来还有什么拓展性，如果各位大佬有什么好的建议请fork或者留言

更新信息
------
<<<<<<< HEAD
0.9.0 Beta : 客户端从python完全重构成C#的GUI界面，进一步完善了聊天和文件传输功能。仍有部分奇怪的碧油鸡留着慢慢修。
=======

0.1.0 Beta C# Rebuild :梦回OICQ。
>>>>>>> 36e55ad4186ca872cebfd010e989701560be0c12

0.2.1 Beta : 一些标准化异常处理

0.2.0 Beta : 加入AES字节流文件加密传输端

0.1.0 Beta ：第一版实现了非对称加密文字流互换
